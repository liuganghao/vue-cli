#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander')
var meta = require('../lib/meta.js')
var vuetemp = require('../template/vuejs.js')
var path = require('path')
const fs = require('fs'),
    core = require('jhipster-core'),
    parse = core.parse,
    parseFromFiles = core.parseFromFiles

var cwd = process.cwd()

if (fs.existsSync(path.join(cwd, 'dsl'))) cwd = path.join(cwd, 'dsl')
if (fs.existsSync(path.join(cwd, '../../dsl'))) cwd = path.join(cwd, '../../dsl')
if (fs.existsSync(path.join(cwd, '../dsl'))) cwd = path.join(cwd, '../dsl')


fs.readdirSync(cwd).forEach((file, index) => {
    if (file.toLowerCase().endsWith('.jdl') || file.toLowerCase().endsWith('.jh')) {
        const input = fs.readFileSync(path.join(cwd, file), 'utf-8').toString()
        try {
            const content = parse(input)
            var com = new meta.com()
            com.code = file.split('.')[0].toLowerCase()
            com.name = com.code
            // comcom.mainEntity = {};
            content.entities.forEach(function (entity) {
                //console.log("start generate  "+entity.name);
                if (entity.name.trim().toLowerCase().indexOf("main") == 0) {
                    com.main.code = entity.name.substr(entity.name.indexOf('_') + 1, entity.name.length).toLowerCase();
                    com.main.name = entity.javadoc
                    entity.body.forEach(p => {
                        let property = new meta.property()
                        property.code = p.name
                        property.name = p.javadoc
                        com.main.propertylist.push(property)
                    })
                } else if (entity.name.trim().toLowerCase().indexOf("enum") == 0) {
                    com.main.code = entity.name.substr(entity.name.indexOf('_') + 1, entity.name.length);
                } else if (entity.name.trim().toLowerCase() == "statemachine") {
                    com.statemachine.code = com.code + '_' + entity.name.trim().toLowerCase()
                    com.statemachine.name = entity.javadoc
                    entity.body.forEach(p => {
                        if (p.type.toString().toLowerCase().trim() == 'state') {
                            let s = new meta.state()
                            s.code = p.name
                            s.name = p.javadoc
                            com.statemachine.statelist.push(s)
                        } else if (p.type.toString().toLowerCase().trim() == 'startstate') {
                            let s = new meta.state()
                            s.code = p.name
                            s.name = p.javadoc
                            com.statemachine.statelist.push(s)
                            com.statemachine.startstate = s.code
                        } else if (p.type.toString().toLowerCase().trim() == 'endstate') {
                            let s = new meta.state()
                            s.code = p.name.trim().toLowerCase()
                            s.name = p.javadoc
                            com.statemachine.statelist.push(s)
                            com.statemachine.endstate = s.code
                        }else {
                            let t = new meta.transition()
                            t.code = p.name
                            t.name = p.javadoc
                            let fromstr = p.type.split('_')[0].toLowerCase()
                            let tostr = p.type.split('_')[1].toLowerCase()
                            t.fromstate = com.statemachine.statelist.find(p=>p.code == fromstr).code
                            t.tostate = com.statemachine.statelist.find(p=>p.code == tostr).code
                            com.statemachine.transitionlist.push(t)
                        }
                    })
                } else {
                    let sub = new meta.subentity()
                    sub.code = entity.name.trim().toLowerCase()
                    sub.name = entity.javadoc
                    entity.body.forEach(p => {
                        let property = new meta.property()
                        property.code = p.name
                        property.name = p.javadoc
                        sub.propertylist.push(property)
                    })
                    com.sublist.push(sub)
                }
            }, this)

            fs.writeFileSync(path.join(cwd, com.code + '.meta.json'), JSON.stringify(com),'utf-8')

            var vuejs = vuetemp.gen_vuejs(com);
            let targetpath = [path.join(cwd, '../vue/src/components'), path.join(cwd, '../web/src/components')]
            for (var index = 0; index < targetpath.length; index++) {
                var p = targetpath[index];
                if (fs.existsSync(p)) {
                    if (!fs.existsSync(path.join(p, com.code))) fs.mkdirSync(path.join(p, com.code))
                    fs.writeFileSync(path.join(path.join(p, com.code), com.code + '.g.js'), vuejs, 'utf-8');
                    console.log('generate file :' + path.join(path.join(p, com.code), com.code + '.g.js').toString());
                } else {
                    fs.writeFileSync(path.join(cwd, com.code + '.g.js'), vuejs, 'utf-8');
                    console.log('generate file :' + path.join(cwd, com.code + '.g.js').toString());
                }
            }
        } catch (error) {
            console.log(file)
            console.log(JSON.stringify(com))
            console.log(error)
        }
    }
})